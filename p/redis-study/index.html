<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="Redis 使用场景及常见面试题 缓存穿透及应对措施 缓存穿透： 查询一个缓存中不存在的数据，并且数据库中也查询不到，从而无法写入缓存，导致每次查询都直接请求到数据库，给数据库造成巨大压力，这种情况大概率遭到了攻击。\n解决方案一： 对不存在的key缓存一个空数据，缺点是会导致内存不断增大。\n解决方案二： 使用布隆过滤器，在查询缓存之前先去布隆过滤器中查询一遍。\n关于布隆过滤器，查看这篇文章，讲解的很细。 布隆(Bloom Filter)过滤器——全面讲解，建议收藏\n缓存击穿及应对措施 缓存击穿： 对于一个设置了过期时间的热点key,恰好在某个时间点过期，且大量并发请求同时访问这个key，于是所有请求直接访问数据库，可能会瞬间把DB压垮。\n解决方案1： 互斥锁。当缓存失效时，不立即访问db,先使用redis的setnx设置一个互斥锁，当操作成功返回时再进行db操作并写入缓存，否则重试get缓存的方法。\n解决方案2： 设置当前key逻辑过期。 大致思路：\n在设置key的时候，设置一个过期时间字段一起存入缓存中，不给当前key设置过期时间。 当查询的时候，从redis中取出数据后判断添加的过期时间字段是否过期。 如果过期，则启动新的线程进行数据同步，当前线程正常返回数据，但这个数据可能不是最新的。 两种方案各有利弊。如果选择数据的强一致性，建议使用互斥锁的方案，性能上可能不高，因为锁需要等待，也有可能产生死锁的问题。\n如果优先考虑高可用性，性能比较高，建议选择给key添加逻辑过期时间，但是数据同步做不到强一致性。\n缓存雪崩及应对措施 缓存雪崩： 在同一时间段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。\n解决方案：\n给不同的key设置随机过期时间 利用redis集群提高服务的可用性（哨兵和集群模式） 给缓存业务添加降级限流策略（降级可作为系统的保底策略，适用于穿透、击穿和雪崩） 给业务添加多级缓存 （Guava和Caffeine） 如何对数据库的数据和缓存的数据进行同步？（读写一致性） 主要分为延时一致性和强一致性的同步。\n延时一致性的业务场景： 比如发表文章、发布商品的场景，不需要实时性很高，像这些场景的业务就可以采用延时一致的解决方案。\n强一致性的业务场景： 比如抢券、秒杀的场景，实时性要求非常高，需要知道是否有券或者商品剩余，这些实时性非常高的场景可以使用强一致性的同步方案。\n允许延时一致的业务采用的异步通知\n使用MQ中间件，更新数据后，再更新缓存 使用Canal中间件，不需要修改业务代码，伪装为mysql的一个从节点，canal通过读取binlog数据更新缓存 强一致性的业务使用Redisson的读写锁进行同步\n共享锁： 获取读锁ReadLock,加锁之后，其他线程可以共享读操作 排他锁： 也叫独占锁WriteLock,加锁之后，阻塞其他线程读写操作。 通过使用排他锁，就可以保证在写数据的时候不会让其他线程读取数据，避免了脏数据。需要注意的是，获取读写锁的读方法和写方法需要使用同一把锁。 延时双删 如果是写操作，我们先把缓存中的数据删除，然后更新数据库，最后再延时删除缓存中的数据，其中这个延时多久不太好确定（数据库主节点同步到从节点的时间不确定多久），在延时的过程中可能出现脏数据（如果延时的时间小于数据同步的时间，那么读取的数据可能是旧数据），并不能保证强一致性。\nRedis的持久化 Redis中有两种持久化方式：RDB和AOF。\nRDB（Redis Database Backup file）是一个快照文件，它是把Redis内存中存储的数据保存到磁盘上，方便从RDB的快照文件中恢复数据。\n1 2 3 4 5 6 7 8 redis-cli save # 由redis主进程执行rdb，会阻塞所有命令 bgsave # 开启子进程执行rdb,避免主进程受影响 # x秒内，如果至少有y个key被修改，则执行bgsave save 900 1 save 300 10 save 60 10000 "><title>Redis系统学习</title><link rel=canonical href=https://farb.github.io/p/redis-study/><link rel=stylesheet href=/scss/style.min.6a692fd055deae459f2a9767f57f3855ba80cafd5041317f24f7360f6ca47cdf.css><meta property='og:title' content="Redis系统学习"><meta property='og:description' content="Redis 使用场景及常见面试题 缓存穿透及应对措施 缓存穿透： 查询一个缓存中不存在的数据，并且数据库中也查询不到，从而无法写入缓存，导致每次查询都直接请求到数据库，给数据库造成巨大压力，这种情况大概率遭到了攻击。\n解决方案一： 对不存在的key缓存一个空数据，缺点是会导致内存不断增大。\n解决方案二： 使用布隆过滤器，在查询缓存之前先去布隆过滤器中查询一遍。\n关于布隆过滤器，查看这篇文章，讲解的很细。 布隆(Bloom Filter)过滤器——全面讲解，建议收藏\n缓存击穿及应对措施 缓存击穿： 对于一个设置了过期时间的热点key,恰好在某个时间点过期，且大量并发请求同时访问这个key，于是所有请求直接访问数据库，可能会瞬间把DB压垮。\n解决方案1： 互斥锁。当缓存失效时，不立即访问db,先使用redis的setnx设置一个互斥锁，当操作成功返回时再进行db操作并写入缓存，否则重试get缓存的方法。\n解决方案2： 设置当前key逻辑过期。 大致思路：\n在设置key的时候，设置一个过期时间字段一起存入缓存中，不给当前key设置过期时间。 当查询的时候，从redis中取出数据后判断添加的过期时间字段是否过期。 如果过期，则启动新的线程进行数据同步，当前线程正常返回数据，但这个数据可能不是最新的。 两种方案各有利弊。如果选择数据的强一致性，建议使用互斥锁的方案，性能上可能不高，因为锁需要等待，也有可能产生死锁的问题。\n如果优先考虑高可用性，性能比较高，建议选择给key添加逻辑过期时间，但是数据同步做不到强一致性。\n缓存雪崩及应对措施 缓存雪崩： 在同一时间段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。\n解决方案：\n给不同的key设置随机过期时间 利用redis集群提高服务的可用性（哨兵和集群模式） 给缓存业务添加降级限流策略（降级可作为系统的保底策略，适用于穿透、击穿和雪崩） 给业务添加多级缓存 （Guava和Caffeine） 如何对数据库的数据和缓存的数据进行同步？（读写一致性） 主要分为延时一致性和强一致性的同步。\n延时一致性的业务场景： 比如发表文章、发布商品的场景，不需要实时性很高，像这些场景的业务就可以采用延时一致的解决方案。\n强一致性的业务场景： 比如抢券、秒杀的场景，实时性要求非常高，需要知道是否有券或者商品剩余，这些实时性非常高的场景可以使用强一致性的同步方案。\n允许延时一致的业务采用的异步通知\n使用MQ中间件，更新数据后，再更新缓存 使用Canal中间件，不需要修改业务代码，伪装为mysql的一个从节点，canal通过读取binlog数据更新缓存 强一致性的业务使用Redisson的读写锁进行同步\n共享锁： 获取读锁ReadLock,加锁之后，其他线程可以共享读操作 排他锁： 也叫独占锁WriteLock,加锁之后，阻塞其他线程读写操作。 通过使用排他锁，就可以保证在写数据的时候不会让其他线程读取数据，避免了脏数据。需要注意的是，获取读写锁的读方法和写方法需要使用同一把锁。 延时双删 如果是写操作，我们先把缓存中的数据删除，然后更新数据库，最后再延时删除缓存中的数据，其中这个延时多久不太好确定（数据库主节点同步到从节点的时间不确定多久），在延时的过程中可能出现脏数据（如果延时的时间小于数据同步的时间，那么读取的数据可能是旧数据），并不能保证强一致性。\nRedis的持久化 Redis中有两种持久化方式：RDB和AOF。\nRDB（Redis Database Backup file）是一个快照文件，它是把Redis内存中存储的数据保存到磁盘上，方便从RDB的快照文件中恢复数据。\n1 2 3 4 5 6 7 8 redis-cli save # 由redis主进程执行rdb，会阻塞所有命令 bgsave # 开启子进程执行rdb,避免主进程受影响 # x秒内，如果至少有y个key被修改，则执行bgsave save 900 1 save 300 10 save 60 10000 "><meta property='og:url' content='https://farb.github.io/p/redis-study/'><meta property='og:site_name' content="Farb's Blog"><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='redis'><meta property='article:published_time' content='2024-05-02T00:00:00+00:00'><meta property='article:modified_time' content='2024-05-02T00:00:00+00:00'><meta name=twitter:title content="Redis系统学习"><meta name=twitter:description content="Redis 使用场景及常见面试题 缓存穿透及应对措施 缓存穿透： 查询一个缓存中不存在的数据，并且数据库中也查询不到，从而无法写入缓存，导致每次查询都直接请求到数据库，给数据库造成巨大压力，这种情况大概率遭到了攻击。\n解决方案一： 对不存在的key缓存一个空数据，缺点是会导致内存不断增大。\n解决方案二： 使用布隆过滤器，在查询缓存之前先去布隆过滤器中查询一遍。\n关于布隆过滤器，查看这篇文章，讲解的很细。 布隆(Bloom Filter)过滤器——全面讲解，建议收藏\n缓存击穿及应对措施 缓存击穿： 对于一个设置了过期时间的热点key,恰好在某个时间点过期，且大量并发请求同时访问这个key，于是所有请求直接访问数据库，可能会瞬间把DB压垮。\n解决方案1： 互斥锁。当缓存失效时，不立即访问db,先使用redis的setnx设置一个互斥锁，当操作成功返回时再进行db操作并写入缓存，否则重试get缓存的方法。\n解决方案2： 设置当前key逻辑过期。 大致思路：\n在设置key的时候，设置一个过期时间字段一起存入缓存中，不给当前key设置过期时间。 当查询的时候，从redis中取出数据后判断添加的过期时间字段是否过期。 如果过期，则启动新的线程进行数据同步，当前线程正常返回数据，但这个数据可能不是最新的。 两种方案各有利弊。如果选择数据的强一致性，建议使用互斥锁的方案，性能上可能不高，因为锁需要等待，也有可能产生死锁的问题。\n如果优先考虑高可用性，性能比较高，建议选择给key添加逻辑过期时间，但是数据同步做不到强一致性。\n缓存雪崩及应对措施 缓存雪崩： 在同一时间段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。\n解决方案：\n给不同的key设置随机过期时间 利用redis集群提高服务的可用性（哨兵和集群模式） 给缓存业务添加降级限流策略（降级可作为系统的保底策略，适用于穿透、击穿和雪崩） 给业务添加多级缓存 （Guava和Caffeine） 如何对数据库的数据和缓存的数据进行同步？（读写一致性） 主要分为延时一致性和强一致性的同步。\n延时一致性的业务场景： 比如发表文章、发布商品的场景，不需要实时性很高，像这些场景的业务就可以采用延时一致的解决方案。\n强一致性的业务场景： 比如抢券、秒杀的场景，实时性要求非常高，需要知道是否有券或者商品剩余，这些实时性非常高的场景可以使用强一致性的同步方案。\n允许延时一致的业务采用的异步通知\n使用MQ中间件，更新数据后，再更新缓存 使用Canal中间件，不需要修改业务代码，伪装为mysql的一个从节点，canal通过读取binlog数据更新缓存 强一致性的业务使用Redisson的读写锁进行同步\n共享锁： 获取读锁ReadLock,加锁之后，其他线程可以共享读操作 排他锁： 也叫独占锁WriteLock,加锁之后，阻塞其他线程读写操作。 通过使用排他锁，就可以保证在写数据的时候不会让其他线程读取数据，避免了脏数据。需要注意的是，获取读写锁的读方法和写方法需要使用同一把锁。 延时双删 如果是写操作，我们先把缓存中的数据删除，然后更新数据库，最后再延时删除缓存中的数据，其中这个延时多久不太好确定（数据库主节点同步到从节点的时间不确定多久），在延时的过程中可能出现脏数据（如果延时的时间小于数据同步的时间，那么读取的数据可能是旧数据），并不能保证强一致性。\nRedis的持久化 Redis中有两种持久化方式：RDB和AOF。\nRDB（Redis Database Backup file）是一个快照文件，它是把Redis内存中存储的数据保存到磁盘上，方便从RDB的快照文件中恢复数据。\n1 2 3 4 5 6 7 8 redis-cli save # 由redis主进程执行rdb，会阻塞所有命令 bgsave # 开启子进程执行rdb,避免主进程受影响 # x秒内，如果至少有y个key被修改，则执行bgsave save 900 1 save 300 10 save 60 10000 "><link rel="shortcut icon" href=/favicon.png><meta name=baidu-site-verification content="codeva-XtyrR4VjKV"></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=https://s3.bmp.ovh/imgs/2024/04/25/1e5e17f5abe2b80d.jpg width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>Farb's Blog</a></h1><h2 class=site-description>像水一样努力，终会水滴石穿</h2></div></header><ol class=menu-social><li><a href=https://gitee.com/farb target=_blank title=Gitee rel=me><!doctype html><svg t="1713884778674" class="icon" viewBox="0 0 1024 1024" p-id="10647" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><path d="M512 1024A512 512 0 11512 0a512 512 0 010 1024zm259.2-568.896H480.32a25.28 25.28.0 00-25.28 25.28v63.232c0 13.952 11.328 25.28 25.28 25.28h177.024c13.952.0 25.28 11.328 25.28 25.28v12.672c0 41.856-33.92 75.84-75.84 75.84H366.592a25.28 25.28.0 01-25.28-25.28V417.216c0-41.92 33.92-75.84 75.84-75.84h353.92a25.28 25.28.0 0025.28-25.344l.064-63.168a25.28 25.28.0 00-25.216-25.28H417.152A189.632 189.632.0 00227.52 417.216v353.92c0 14.016 11.328 25.28 25.28 25.28h372.992a170.624 170.624.0 00170.624-170.624V480.384a25.28 25.28.0 00-25.28-25.28z" fill="#C71D23" p-id="10648"/></svg></a></li><li><a href=https://github.com/farb target=_blank title=GitHub rel=me><!doctype html><svg t="1713884694671" class="icon" viewBox="0 0 1024 1024" p-id="9399" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><path d="M64 512c0 195.2 124.8 361.6 300.8 422.4 22.4 6.4 19.2-9.6 19.2-22.4v-76.8c-134.4 16-140.8-73.6-150.4-89.6-19.2-32-60.8-38.4-48-54.4 32-16 64 3.2 99.2 57.6 25.6 38.4 76.8 32 105.6 25.6 6.4-22.4 19.2-44.8 35.2-60.8C281.6 691.2 224 604.8 224 502.4c0-48 16-96 48-131.2-22.4-60.8.0-115.2 3.2-121.6 57.6-6.4 118.4 41.6 124.8 44.8 32-9.6 70.4-12.8 112-12.8s80 6.4 112 12.8c12.8-9.6 67.2-48 121.6-44.8 3.2 6.4 25.6 57.6 6.4 118.4 32 38.4 48 83.2 48 131.2.0 102.4-57.6 188.8-201.6 214.4 22.4 22.4 38.4 54.4 38.4 92.8v112c0 9.6.0 19.2 16 19.2C832 876.8 960 710.4 960 512c0-246.4-201.6-448-448-448S64 265.6 64 512z" fill="#040000" p-id="9400"/></svg></a></li><li><a href=https://leetcode.cn/u/int2147483647 target=_blank title=力扣 rel=me><!doctype html><svg t="1713884461345" class="icon" viewBox="0 0 1024 1024" p-id="4333" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><path d="M701.28 766.86a58.9 58.9.0 0183.1 83.52l-102.24 102c-94.3 94.16-248 95.52-344 3.16-.56-.52-43.26-42.4-184.12-180.54-93.72-92-103.06-238.94-14.88-333.36l164.44-176C391.12 172 552.46 161.68 652.54 242.6l149.34 120.78a58.92 58.92.0 01-74 91.76L578.54 334.36c-52.34-42.34-144-36.52-189.06 11.84l-164.44 176c-42.94 46-38.22 120 11.26 168.54l183.26 179.7c49.86 48 130.48 47.3 179.42-1.58z" fill="#FFA116" p-id="4334"/><path d="M452.94 664.7a58.96 58.96.0 010-118h434a58.96 58.96.0 010 118z" fill="#B3B3B3" p-id="4335"/><path d="M534.22 18.68a58.9 58.9.0 1186 80.56L225.1 522.28c-42.92 46-38.22 120 11.24 168.54l182.46 178.9A58.92 58.92.0 01336.46 954L154.06 775.08c-93.7-92-103.04-238.94-14.84-333.36z" p-id="4336"/></svg></a></li><li><a href=https://www.cnblogs.com/farb target=_blank title=博客园 rel=me><!doctype html><svg t="1713884612994" class="icon" viewBox="0 0 1024 1024" p-id="8439" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><path d="M851.40363594 172.59636406c-187.46181844-187.46181844-491.34545437-187.46181844-678.80727188.0-187.46181844 187.46181844-187.46181844 491.34545437.0 678.80727188 187.46181844 187.46181844 491.34545437 187.46181844 678.80727188.0 187.46181844-187.46181844 187.46181844-491.34545437.0-678.80727188zM387.33090875 728.08727281a47.08363594 47.08363594.0 11-66.63272719-66.50181843 47.08363594 47.08363594.0 0166.63272719 66.50181843zm205.52727281 1.39636313a38.74909125 38.74909125.0 01-76.62545437-11.52h-.04363594a6.54545437 6.54545437.0 00-.04363688.30545531V717.92c.30545438-2.61818156 2.05090875-20.72727281-2.96727281-44.98909125a174.24 174.24.0 00-48.56727281-89.28 172.10181844 172.10181844.0 00-88.8-48.30545438 156.69818156 156.69818156.0 00-42.45818156-2.92363593 38.66181844 38.66181844.0 01-35.38909125-65.32363688 38.61818156 38.61818156.0 0121.12-10.8218175v-.2181825c4.45090875-.74181844 111.14181844-16.45090875 200.33454562 72.74181844 89.01818156 89.01818156 74.18181844 196.14545438 73.44 200.72727281zm175.2 7.59272812a38.74909125 38.74909125.0 01-65.67272719 21.3818175 39.49090875 39.49090875.0 01-11.65090875-33.73090875c.08727281-.34909125 5.10545437-37.48363594-5.06181843-88.97454562C672.36363594 568.37818157 640.37818156 508.85818156 590.72 458.85090875c-50.00727281-49.70181844-109.52727281-81.64363594-176.94545438-94.95272719-51.49090875-10.16727281-88.58181844-5.19272719-89.01818156-5.14909031h.21818156-.04363687a39.92727281 39.92727281.0 01-44.68363594-32.90181844 38.83636406 38.83636406.0 0132.20363594-44.37818156c1.92-.30545438 47.86909125-7.33090875 111.27272719 4.36363594a411.75272719 411.75272719.0 01106.25454562 34.95272718A425.76 425.76.0 01644.61090875 403.04l.91636406.96.96.87272719a425.89090875 425.89090875.0 0182.25454563 114.72c16.40727281 33.6 28.14545437 69.29454562 34.99636312 106.21090875 11.65090875 63.40363594 4.66909125 109.35272719 4.32 111.27272812z" fill="#1296db" p-id="8440"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>主页</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>归档</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>搜索</span></a></li><li><a href=/%E9%93%BE%E6%8E%A5/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>链接</span></a></li><li class=menu-bottom-section><ol class=menu><li id=i18n-switch><svg class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg>
<select name=language title=language onchange="window.location.href=this.selectedOptions[0].value"><option value=https://farb.github.io/ selected>English</option><option value=https://farb.github.io/zh-cn/>中文</option></select></li><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#redis-使用场景及常见面试题>Redis 使用场景及常见面试题</a></li><li><a href=#缓存穿透及应对措施>缓存穿透及应对措施</a></li><li><a href=#缓存击穿及应对措施>缓存击穿及应对措施</a></li><li><a href=#缓存雪崩及应对措施>缓存雪崩及应对措施</a></li><li><a href=#如何对数据库的数据和缓存的数据进行同步读写一致性>如何对数据库的数据和缓存的数据进行同步？（读写一致性）</a></li><li><a href=#redis的持久化>Redis的持久化</a></li><li><a href=#redis的数据过期策略>Redis的数据过期策略</a></li><li><a href=#redis的数据淘汰策略>Redis的数据淘汰策略</a></li><li><a href=#分布式锁>分布式锁</a><ol><li><a href=#redisson分布式锁的看门狗watch-dog机制>Redisson分布式锁的看门狗（Watch Dog）机制</a></li><li><a href=#redisson的分布式锁是可重入的>redisson的分布式锁是可重入的</a></li><li><a href=#redisson分布式锁的主从一致性>redisson分布式锁的主从一致性</a></li><li><a href=#分布式锁faq>分布式锁FAQ</a></li></ol></li><li><a href=#redis集群方案>Redis集群方案</a><ol><li><a href=#主从复制>主从复制</a></li><li><a href=#哨兵模式>哨兵模式</a></li><li><a href=#分片集群>分片集群</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/redis/ style=background-color:#2a9d8f;color:#fff>Redis</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/redis-study/>Redis系统学习</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>2024-05-02</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>3 minute read</time></div></footer></div></header><section class=article-content><h2 id=redis-使用场景及常见面试题>Redis 使用场景及常见面试题</h2><p><img src=https://s3.bmp.ovh/imgs/2024/05/02/ea8c494ed0aebc7f.png loading=lazy></p><h2 id=缓存穿透及应对措施>缓存穿透及应对措施</h2><p><strong>缓存穿透：</strong> 查询一个缓存中不存在的数据，并且数据库中也查询不到，从而无法写入缓存，导致每次查询都直接请求到数据库，给数据库造成巨大压力，这种情况大概率遭到了攻击。</p><p><strong>解决方案一：</strong> 对不存在的key缓存一个空数据，缺点是会导致内存不断增大。</p><p><strong>解决方案二：</strong> 使用布隆过滤器，在查询缓存之前先去布隆过滤器中查询一遍。</p><p>关于布隆过滤器，查看这篇文章，讲解的很细。
<a class=link href=https://blog.csdn.net/qq_41125219/article/details/119982158 target=_blank rel=noopener>布隆(Bloom Filter)过滤器——全面讲解，建议收藏</a></p><h2 id=缓存击穿及应对措施>缓存击穿及应对措施</h2><p><strong>缓存击穿：</strong> 对于一个设置了过期时间的热点key,恰好在某个时间点过期，且大量并发请求同时访问这个key，于是所有请求直接访问数据库，可能会瞬间把DB压垮。</p><p><strong>解决方案1：</strong> 互斥锁。当缓存失效时，不立即访问db,先使用redis的setnx设置一个互斥锁，当操作成功返回时再进行db操作并写入缓存，否则重试get缓存的方法。</p><p><strong>解决方案2：</strong> 设置当前key逻辑过期。
大致思路：</p><ol><li>在设置key的时候，设置一个过期时间字段一起存入缓存中，不给当前key设置过期时间。</li><li>当查询的时候，从redis中取出数据后判断添加的过期时间字段是否过期。</li><li>如果过期，则启动新的线程进行数据同步，当前线程正常返回数据，但这个数据可能不是最新的。</li></ol><p>两种方案各有利弊。如果选择数据的强一致性，建议使用互斥锁的方案，性能上可能不高，因为锁需要等待，也有可能产生死锁的问题。</p><p>如果优先考虑高可用性，性能比较高，建议选择给key添加逻辑过期时间，但是数据同步做不到强一致性。</p><h2 id=缓存雪崩及应对措施>缓存雪崩及应对措施</h2><p><strong>缓存雪崩：</strong> 在同一时间段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p><p><strong>解决方案：</strong></p><ol><li>给不同的key设置随机过期时间</li><li>利用redis集群提高服务的可用性（哨兵和集群模式）</li><li>给缓存业务添加降级限流策略（降级可作为系统的保底策略，适用于穿透、击穿和雪崩）</li><li>给业务添加多级缓存 （Guava和Caffeine）</li></ol><h2 id=如何对数据库的数据和缓存的数据进行同步读写一致性>如何对数据库的数据和缓存的数据进行同步？（读写一致性）</h2><p>主要分为延时一致性和强一致性的同步。</p><p><strong>延时一致性的业务场景：</strong> 比如发表文章、发布商品的场景，不需要实时性很高，像这些场景的业务就可以采用延时一致的解决方案。</p><p><strong>强一致性的业务场景：</strong> 比如抢券、秒杀的场景，实时性要求非常高，需要知道是否有券或者商品剩余，这些实时性非常高的场景可以使用强一致性的同步方案。</p><p><strong>允许延时一致的业务采用的异步通知</strong></p><ol><li>使用MQ中间件，更新数据后，再更新缓存</li><li>使用Canal中间件，不需要修改业务代码，伪装为mysql的一个从节点，canal通过读取binlog数据更新缓存</li></ol><p><strong>强一致性的业务使用Redisson的读写锁进行同步</strong></p><ol><li>共享锁： 获取读锁ReadLock,加锁之后，其他线程可以共享读操作</li><li>排他锁： 也叫独占锁WriteLock,加锁之后，阻塞其他线程读写操作。
通过使用排他锁，就可以保证在写数据的时候不会让其他线程读取数据，避免了脏数据。需要注意的是，获取读写锁的读方法和写方法需要使用同一把锁。</li></ol><p><strong>延时双删</strong><br>如果是写操作，我们先把缓存中的数据删除，然后更新数据库，最后再延时删除缓存中的数据，其中这个延时多久不太好确定（数据库主节点同步到从节点的时间不确定多久），在延时的过程中可能出现脏数据（如果延时的时间小于数据同步的时间，那么读取的数据可能是旧数据），并不能保证强一致性。</p><h2 id=redis的持久化>Redis的持久化</h2><p>Redis中有两种持久化方式：RDB和AOF。<br>RDB（Redis Database Backup file）是一个快照文件，它是把Redis内存中存储的数据保存到磁盘上，方便从RDB的快照文件中恢复数据。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>redis-cli
</span></span><span class=line><span class=cl>save <span class=c1># 由redis主进程执行rdb，会阻塞所有命令</span>
</span></span><span class=line><span class=cl>bgsave <span class=c1># 开启子进程执行rdb,避免主进程受影响</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># x秒内，如果至少有y个key被修改，则执行bgsave</span>
</span></span><span class=line><span class=cl>save <span class=m>900</span> <span class=m>1</span>
</span></span><span class=line><span class=cl>save <span class=m>300</span> <span class=m>10</span>
</span></span><span class=line><span class=cl>save <span class=m>60</span> <span class=m>10000</span>
</span></span></code></pre></td></tr></table></div></div><p><img src=https://s3.bmp.ovh/imgs/2024/05/05/e5df89608f9d4ffd.png loading=lazy></p><p>AOF（Append Only File）是追加文件，当redis操作写命令的时候，都会存储在这个文件中。当需要恢复数据时，重新执行该文件的命令即可恢复数据。</p><p>修改redis.config 文件来修改配置</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># AOF 默认是关闭的，默认是no,开启需要设置为yes</span>
</span></span><span class=line><span class=cl>appendonly yes
</span></span><span class=line><span class=cl><span class=c1># AOF文件的名称</span>
</span></span><span class=line><span class=cl>appendfilename <span class=s2>&#34;appendonly.aof&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 每执行一次写命令，立即记录到aof文件</span>
</span></span><span class=line><span class=cl>appendfsync always
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 写命令执行完先放入aof缓冲区，每隔一秒将缓冲区的数据写到aof文件，是默认方案</span>
</span></span><span class=line><span class=cl>appendfsync everysec
</span></span><span class=line><span class=cl><span class=c1># 写命令执行完先放入aof缓冲区，由操作系统决定何时将缓冲区内容写入磁盘</span>
</span></span><span class=line><span class=cl>appendfsync no
</span></span></code></pre></td></tr></table></div></div><div class=table-wrapper><table><thead><tr><th>配置项</th><th>刷盘时机</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>always</td><td>同步刷盘</td><td>可靠性高，几乎不丢数据</td><td>性能影响大</td></tr><tr><td>everysec</td><td>每秒刷盘</td><td>性能适中</td><td>最多丢失1秒数据</td></tr><tr><td>no</td><td>操作系统控制</td><td>性能最好</td><td>可靠性较差，可能丢失大量数据</td></tr></tbody></table></div><p><strong>bgrewriteaof命令对aof文件执行重写，用最少的命令达到相同效果</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># AOF 文件比上次文件增长超过多少百分比则触发重写</span>
</span></span><span class=line><span class=cl>auto-aof-rewrite-percentage <span class=m>100</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># AOF文件体积最小多大以上才触发重写</span>
</span></span><span class=line><span class=cl>auto-aof-rewrite-min-size 64mb
</span></span></code></pre></td></tr></table></div></div><div class=table-wrapper><table><thead><tr><th></th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>持久化方式</td><td>定时对整个内存做快照</td><td>记录每次执行的命令</td></tr><tr><td>数据完整性</td><td>不完整，两次备份之间会丢失</td><td>相对完整，取决于刷盘策略</td></tr><tr><td>文件大小</td><td>会有压缩，文件体积小</td><td>记录命令，文件体积很大</td></tr><tr><td>宕机恢复速度</td><td>很快</td><td>慢</td></tr><tr><td>数据恢复优先级</td><td>低，因为数据完整性不如AOF</td><td>高，因为数据完整性更高</td></tr><tr><td>系统资源占用</td><td>高，大量CPU和内存消耗</td><td>低，主要是IO磁盘资源，但AOF重写时会占用大量CPU和内存</td></tr><tr><td>使用场景</td><td>可以容忍数分钟的数据丢失，追求更快的启动速度</td><td>对数据安全性要求较高</td></tr></tbody></table></div><p><strong>这两种存储方式，哪种恢复的更快呢</strong><br>RDB是二进制文件，在保存的时候体积也是比较小的，它恢复的较快，但是它有可能会丢失数据，通常也会使用AOF恢复数据，虽然AOF的恢复速度慢，但是它丢失的数据风险较小，在AOF文件中可以设置刷盘策略，使用较多的是每秒批量写入一次命令。</p><h2 id=redis的数据过期策略>Redis的数据过期策略</h2><p><strong>惰性删除：</strong> key的过期时间到期后，不会自动删除，而是当再次查询时，先检查key是否过期，如果过期则删除，否则直接返回该key</p><p><strong>定期清理：</strong> 每隔一段时间，对一些key进行检查，删除过期的key。定期清理有两种模式：</p><ol><li>slow模式是定时任务，执行频率默认为10hz,每次不超过25ms,通过修改redis.conf的hz选项调整次数。</li><li>fast模式执行频率不固定，每次事件循环会尝试执行，但每次间隔不低于2ms,每次耗时不超过1ms。
Redis的过期删除策略，是惰性删除和定期删除两种策略配合使用。</li></ol><h2 id=redis的数据淘汰策略>Redis的数据淘汰策略</h2><p><strong>数据的淘汰策略：</strong> 当Redis的内存不够用时，再向redis中添加新的key时，那么redis就会按照某种规则将内存中的数据删除掉，这种规则称为内存的淘汰策略。</p><ol><li>noeviction: 不淘汰任何key，但是内存满时不允许写入任何数据，直接报错，这是默认策略。</li><li>volatile-ttl: 对设置了ttl（Time to live 存活时间）的key，比较key的剩余ttl值，ttl越小越先被淘汰。</li><li>allkeys-random: 全体key随机进行淘汰</li><li>volatile-random: 对设置了ttl的key，随机进行淘汰</li><li>allkeys-lru: 对全体key，按照lru算法淘汰</li><li>volatile-lru: 对设置了ttl的key按照lru算法淘汰</li><li>allkeys-lfu: 对所有key按照lfu算法淘汰</li><li>volatile-lfu: 对设置了ttl的key,按照lfu算法淘汰</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># redis.conf中设置</span>
</span></span><span class=line><span class=cl>maxmemory-policy allkeys-lru
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># redis实例动态设置</span>
</span></span><span class=line><span class=cl>CONFIG SET maxmemory-policy allkeys-lru
</span></span></code></pre></td></tr></table></div></div><p><strong>LRU（Least Recently Used）算法</strong> ：最近最少使用。用当前时间减去最后一次访问时间，这个值越大淘汰优先级越高。<br><strong>LFU（Least Frequently Used）算法</strong> : 最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高。</p><p><strong>使用建议：</strong></p><ol><li>优先使用allkeys-lru淘汰策略。充分利用LRU算法的优势，把最常访问的数据保留在缓存中，如果业务有明显的冷热数据区分，建议使用。</li><li>如果业务中数据访问频率差别不大，没有明显的冷热数据区分，建议使用随机淘汰策略allkeys-random。</li><li>如果业务中有置顶的需求，可以使用volatile-lru策略，同时置顶数据不要设置过期时间，那么这些数据就会一直不被删除，会淘汰其他设置过期时间的数据。</li><li>如果业务中有短时高频访问的数据，建议使用allkeys-lfu或volatile-lfu策略。</li></ol><p>问：数据库中有1000w数据，Redis只能缓存20w数据，如何保证redis中的数据都是热点数据？<br>答：使用allkeys-lru（最近最少访问的数据优先淘汰）淘汰策略，留下来的都是经常访问的热点数据。</p><p>问：Redis的内存使用完了会发生什么？<br>答：主要看设置的数据淘汰策略是什么，如果是默认的noevction,内存满后继续添加key会报错。其他的策略都会淘汰某些key后，继续写入。</p><h2 id=分布式锁>分布式锁</h2><p>分布式锁一般是多个进程同步数据时加的锁，而平时代码中的写的lock，是同一个进程下多个线程同步时加的锁。</p><p>通常情况下，使用分布式锁的场景有：<strong>集群情况下的定时任务、抢券、幂等性场景</strong></p><p>Redis分布式锁主要利用Redis的setnx命令，setnx是SET if not exist的简写。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=err>#</span> <span class=err>获取锁</span><span class=p>,</span><span class=n>NX是互斥</span><span class=err>，</span><span class=n>EX是设置超时</span><span class=p>,</span><span class=n>EX必须设置</span><span class=err>，否则可能因为业务超时或服务宕机等原因而无法释放锁。添加超时时间后，到期会自动释放锁</span>
</span></span><span class=line><span class=cl><span class=n>SET</span> <span class=k>lock</span> <span class=k>value</span> <span class=n>NX</span> <span class=n>EX</span> <span class=m>10</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>#</span> <span class=err>释放锁，删除即可</span>
</span></span><span class=line><span class=cl><span class=n>DEL</span> <span class=n>key</span>
</span></span></code></pre></td></tr></table></div></div><p>问：Redis分布式锁如何合理地控制锁的有效时长？<br>答：1.根据业务执行时间预估（不靠谱）；2.给锁续期</p><h3 id=redisson分布式锁的看门狗watch-dog机制>Redisson分布式锁的看门狗（Watch Dog）机制</h3><p><img src=https://s3.bmp.ovh/imgs/2024/05/08/d95ba1c2589f1b46.png loading=lazy></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>redisLock</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 获取锁（可重入锁）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>RLock</span><span class=w> </span><span class=n>lock</span><span class=o>=</span><span class=n>redissonClient</span><span class=p>.</span><span class=na>getLock</span><span class=p>(</span><span class=s>&#34;lockKey&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 尝试获取锁，参数含义分别是获取锁的最大等待时间（期间会重试），锁自动释放时间(默认30)，时间单位</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// boolean isLock=lock.tryLock(10,30,TimeUnit.SECONDS);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 加锁、设置过期时间等操作都是通过lua脚本完成</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>boolean</span><span class=w> </span><span class=n>isLock</span><span class=o>=</span><span class=n>lock</span><span class=p>.</span><span class=na>tryLock</span><span class=p>(</span><span class=n>10</span><span class=p>,</span><span class=n>TimeUnit</span><span class=p>.</span><span class=na>SECONDS</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>isLock</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=k>try</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>         </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;获取锁成功&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=p>}</span><span class=k>finally</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 释放锁</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>lock</span><span class=p>.</span><span class=na>unlock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>lua学习教程</strong> <a class=link href=https://www.runoob.com/lua/lua-tutorial.html target=_blank rel=noopener>https://www.runoob.com/lua/lua-tutorial.html</a></p><h3 id=redisson的分布式锁是可重入的>redisson的分布式锁是可重入的</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>add1</span><span class=p>(){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>RLock</span><span class=w> </span><span class=n>lock</span><span class=o>=</span><span class=n>redissonClient</span><span class=p>.</span><span class=na>getLock</span><span class=p>(</span><span class=s>&#34;locker&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>boolean</span><span class=w> </span><span class=n>isLcok</span><span class=o>=</span><span class=n>lock</span><span class=p>.</span><span class=na>tryLock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 执行业务</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>add2</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 释放锁</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>lock</span><span class=p>.</span><span class=na>unlock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>add2</span><span class=p>(){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>RLock</span><span class=w> </span><span class=n>lock</span><span class=o>=</span><span class=n>redissonClient</span><span class=p>.</span><span class=na>getLock</span><span class=p>(</span><span class=s>&#34;locker&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 如果是同一个线程，则可以获取锁，否则互斥</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>boolean</span><span class=w> </span><span class=n>isLcok</span><span class=o>=</span><span class=n>lock</span><span class=p>.</span><span class=na>tryLock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 执行业务</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 释放锁</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>lock</span><span class=p>.</span><span class=na>unlock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>通过哈希结构区分锁的不同线程访问记录。field保存线程唯一标识，value保存重入次数。</p><p><img src=https://s3.bmp.ovh/imgs/2024/05/08/3672843889a63326.png loading=lazy></p><h3 id=redisson分布式锁的主从一致性>redisson分布式锁的主从一致性</h3><p>在哨兵模式等主从同步模式中，如果主节点Master没有成功同步数据到从节点Slave时，有一个请求线程获取了一个锁，与此同时，Master主节点宕机了，然后会从一个从节点Salve中选举一个主节点，又一个请求线程获取了同一个锁。这种场景就会导致多个线程获取同一把锁，失去了锁的意义，可能或导致脏数据。</p><p>RedLock(红锁)： 不能只在一个redis实例上创建锁，而应该在多个（n/2+1）实例上创建锁，（n/2+1）表示至少一半的实例。</p><p>官方不建议使用红锁解决主从不一致问题。<strong>因为实现复杂，且高并发下性能差，运维繁琐。</strong></p><p>那如何解决这一问题呢？
<strong>Redis是AP思想（高可用），应该使用CP思想的Zookeeper。</strong></p><h3 id=分布式锁faq>分布式锁FAQ</h3><p>问：Redis分布式锁如何实现？<br>答：在redis中提供了一个命令setnx(set if not exists)，由于redis是单线程的，用来命令之后，只能有一个客户端对某个key设置值，在没有过期或者删除key时，其他客户端是不能设置这个key的。</p><p>问：如何控制redis分布式锁的有效时长呢？<br>答：redis的setnx指令不好控制这个问题，可以采用redisson框架实现。在redisson中可以手动加锁，并且可以控制锁的失效时间和等待时间，当锁住的业务还没执行完毕时，redisson中引入了看门狗机制，就是说每隔一段时间就检查当前业务是否持有锁，如果持有锁就增加锁的持有时间，当业务执行完成后释放锁就可以了。还有一个好处是，在高并发场景下，如果客户1获取了锁，客户2来了后并不会马上拒绝，它会不断尝试获取锁，如果客户1释放锁之后，客户2会马上持有锁，性能也得到了提升。</p><p>问：redisson的分布式锁是可以重入的吗？<br>答：是可重入的。这样做是为了避免死锁的发生。这个重入其实在内部就是判断是否是当前线程持有的锁，如果是就会计数器加1，如果释放锁就会减1。在存储数据的时候采用的是hash结构，大key可以按照业务进行定制，小key是线程的唯一标识，value是当前线程的重入次数。</p><p>问： redisson的分布式锁能解决主从一致性的问题吗？<br>答： 不能。比如，当线程1加锁成功后，master节点数据会异步复制到从节点slave，此时当前持有redis锁的master节点宕机，slave节点被提升为新的master节点，之前的master节点变成slave节点，假如现在又来了一个线程2，两个线程持有同一把锁，执行业务可能导致脏数据问题。其实Redis采用的是高并发思想（AP），可以考虑使用强一致性思想的Zookeeper（CP）。</p><h2 id=redis集群方案>Redis集群方案</h2><h3 id=主从复制>主从复制</h3><p>单节点的Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。一般是一主多从，主节点负责写，从节点负责读。主节点将数据同步到从节点。<br><strong>全量同步原理：</strong></p><ol><li>从节点请求主节点同步数据（replicationId,offset）</li><li>主节点判断是否是第一次请求，是第一次请求就与从节点同步版本信息（replicationId和offset）</li><li>主节点执行bgsave,生成rdb文件后，发送给从节点执行</li><li>在rdb生成执行期间，主节点会以命令的方式记录到缓冲区（一个日志文件repl_baklog）</li><li>把生成的命令日志文件发送到从节点执行，从而完成全量数据同步</li></ol><p><img src=https://s3.bmp.ovh/imgs/2024/05/09/9e8f503de41a3e63.png loading=lazy></p><p><strong>增量同步原理：</strong></p><ol><li>从节点从主节点请求同步数据，主节点判断不是第一次请求，不是第一次请求就获取从节点的offset值</li><li>主节点从命令日志文件中获取offset值之后的数据，发送到从节点进行数据同步
<img src=https://s3.bmp.ovh/imgs/2024/05/09/e1b797d6b277dd70.png loading=lazy></li></ol><h3 id=哨兵模式>哨兵模式</h3><p>Redis提供了哨兵Sentinel机制来实现主从集群的自动故障恢复。<br>哨兵的作用：</p><ol><li>监控：Sentinel会不断检查Master和Slave是否按预期工作；</li><li>自动故障恢复：如果master故障，Sentinel会自动将一个slave提升为master，当故障实例恢复后以新的master为主；</li><li>通知：Sentinel充当redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis客户端。</li></ol><p>这样，通过哨兵模式就可以实现redis的高并发高可用。</p><p><img src=https://s3.bmp.ovh/imgs/2024/05/10/35881a0185c2560f.png loading=lazy></p><p><strong>服务状态监控</strong>
Sentinel基于心跳机制监测服务状态，每隔1s向集群的实例发送ping命令：</p><ul><li>主观下线： 如果某个Sentinel节点发现某个实例在规定时间内没有响应，则认为该实例主观下线；</li><li>客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例客观下线。quorum值最好超过sentinel实例数量的一半</li></ul><p>哨兵选主规则：</p><ol><li>首先判断主节点与从节点的断开时间长短，如果超过指定值就排除该从节点；</li><li>然后判断从节点的slave-priority的值，越小优先级越高；</li><li>如果slave-priority的值一样，则判断slave节点的offset值，越大说明从主节点同步的数据越多，优先级也就越高；</li><li>最后时判断slave节点的运行id大小，越小优先级越高</li></ol><p><strong>Redis集群（哨兵模式）脑裂问题</strong>
集群脑裂redis的主节点、从节点和哨兵集群Sentinel处于不同的网络分区，使得sentinel没有能够检测到主节点的心跳，所以就通过选举的方式提升一个从节点作为主节点，这样就存在了两个主节点master，就像大脑裂开了一样，这样会导致客户端还在老的主节点那里写入数据，新节点无法同步数据，当网络恢复后，sentinel会将老的主节点降级为从节点，这时再从新的master同步数据，就会导致数据丢失。</p><p><strong>解决办法：</strong> Redis中有两个配置参数：</p><ol><li><code>min-replicas-to-write 1</code> 表示最少的slave节点为1个</li><li><code>min-replicas-max-lag 5</code> 表示数据复制和同步的延迟不能超过5秒</li></ol><p>达不到这两个要求的就拒绝请求，可以避免大量数据丢失。</p><p>一般规模的应用使用一主一从+哨兵就可以了，单节点不超过10GB内存，如果Redis内存不足则可以给不同的服务分配独立的Redis主从节点。</p><h3 id=分片集群>分片集群</h3></section><footer class=article-footer><section class=article-tags><a href=/tags/redis/>Redis</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section>页面浏览量<span id=busuanzi_value_page_pv>Loading</span></section><section><strong>如果觉得我的博客能帮助到你，欢迎点击右侧的赞助进行投喂。如有技术咨询，也可以加本人好友。</strong></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/redis_in_action_13_redis_springcloud/><div class=article-details><h2 class=article-title>基于Docker的Redis实战-Redis与SpringCloud微服务整合</h2></div></a></article><article><a href=/p/redis_in_action_12_redis_springboot/><div class=article-details><h2 class=article-title>基于Docker的Redis实战-Redis与SpringBoot整合</h2></div></a></article><article><a href=/p/redis_in_action_11_lua/><div class=article-details><h2 class=article-title>基于Docker的Redis实战-Redis整合Lua脚本</h2></div></a></article><article><a href=/p/redis_in_action_10_mysql_mycat/><div class=article-details><h2 class=article-title>基于Docker的Redis实战-Redis整合Mysql集群和MyCat分库分表组件</h2></div></a></article><article><a href=/p/redis_in_action_09_redis_practical_cases/><div class=article-details><h2 class=article-title>基于Docker的Redis实战-Redis消息队列、分布式锁、限流、压力测试综合实践案例</h2></div></a></article></div></div></aside><script src=//unpkg.com/@waline/client@v2/dist/waline.js></script><link href=//unpkg.com/@waline/client@v2/dist/waline.css rel=stylesheet><div id=waline class=waline-container></div><style>.waline-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding);--waline-font-size:var(--article-font-size)}.waline-container .wl-count{color:var(--card-text-color-main)}</style><script>Waline.init({avatar:"",dark:'html[data-scheme="dark"]',el:"#waline",emoji:["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo"],lang:"zh-cn",locale:{admin:"Admin",placeholder:null},placeholder:"",requiredMeta:["name","email"],serverURL:"https://blog.comment.farb.top",visitor:""})</script><footer class=site-footer><section class=copyright>&copy;
2024 -
2025 Farb's Blog</section><section class=powerby>总访客数：<span id=busuanzi_value_site_uv style=margin-right:10px>Loading</span> 总访问量：<span id=busuanzi_value_site_pv style=margin-right:10px>Loading</span>
<a href=https://eu.umami.is/share/y6kXo4CE3oYHXQ37/farb.github.io style=color:blue target=_blank>实时统计</a><br><span id=span_show_age style=margin-right:30px><br>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script><script src=https://cdn.jsdelivr.net/npm/tctip@1.0.4/dist/tctip-1.0.3.min.js></script><script>new tctip({top:"20%",button:{id:8,type:"zanzhu"},list:[{type:"alipay",qrImg:"https://github.com/user-attachments/assets/3ac3da80-aa15-4ab7-bee7-7292a08fcda1"},{type:"wechat",qrImg:"https://github.com/user-attachments/assets/efc07320-351b-45f3-9a89-a938050da4ef"},{type:"weixin",name:"加好友",icon:"https://s3.bmp.ovh/imgs/2024/04/24/6feafb7f63995dfe.png",qrImg:"https://s3.bmp.ovh/imgs/2024/04/24/e2ae8bd59da6e3a8.jpg",desc:"微信:beingBetterSelf"}]}).init()</script><script defer src=https://cn.vercount.one/js></script><script defer src=https://analytics.eu.umami.is/script.js data-website-id=0a12e949-0500-4ff1-872c-b8969b376add></script><script defer language=javascript>var uptime_1="本站已经开心运行 ",uptime_2=" 天 ",uptime_3=" 小时 ",uptime_4=" 分 ",uptime_5=" 秒";function show_date_time(){window.setTimeout(show_date_time,1e3),BirthDay=new Date("4/08/2024 22:54:23"),today=new Date,timeold=today.getTime()-BirthDay.getTime(),sectimeold=timeold/1e3,secondsold=Math.floor(sectimeold),msPerDay=24*60*60*1e3,e_daysold=timeold/msPerDay,daysold=Math.floor(e_daysold),e_hrsold=(e_daysold-daysold)*24,hrsold=Math.floor(e_hrsold),e_minsold=(e_hrsold-hrsold)*60,minsold=Math.floor((e_hrsold-hrsold)*60),seconds=Math.floor((e_minsold-minsold)*60),document.getElementById("span_show_age").innerHTML=uptime_1+daysold+uptime_2+hrsold+uptime_3+minsold+uptime_4+seconds+uptime_5}show_date_time()</script></body></html>