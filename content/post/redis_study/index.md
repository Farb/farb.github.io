---
title: Redis系统学习
description:
slug: redis-study
date: 2024-05-02
image: 
categories:
    - Redis
tags:
    - redis
weight: 1       # You can add weight to some posts to override the default sorting (date descending)
---

## 1. Redis 使用场景及常见面试题

![](https://s3.bmp.ovh/imgs/2024/05/02/ea8c494ed0aebc7f.png)

## 2. 缓存穿透及应对措施

**缓存穿透：** 查询一个缓存中不存在的数据，并且数据库中也查询不到，从而无法写入缓存，导致每次查询都直接请求到数据库，给数据库造成巨大压力，这种情况大概率遭到了攻击。

**解决方案一：** 对不存在的key缓存一个空数据，缺点是会导致内存不断增大。

**解决方案二：** 使用布隆过滤器，在查询缓存之前先去布隆过滤器中查询一遍。

关于布隆过滤器，查看这篇文章，讲解的很细。 
[布隆(Bloom Filter)过滤器——全面讲解，建议收藏](https://blog.csdn.net/qq_41125219/article/details/119982158)

## 3. 缓存击穿及应对措施
**缓存击穿：** 对于一个设置了过期时间的热点key,恰好在某个时间点过期，且大量并发请求同时访问这个key，于是所有请求直接访问数据库，可能会瞬间把DB压垮。

**解决方案1：** 互斥锁。当缓存失效时，不立即访问db,先使用redis的setnx设置一个互斥锁，当操作成功返回时再进行db操作并写入缓存，否则重试get缓存的方法。

**解决方案2：** 设置当前key逻辑过期。
大致思路：
1. 在设置key的时候，设置一个过期时间字段一起存入缓存中，不给当前key设置过期时间。
2. 当查询的时候，从redis中取出数据后判断添加的过期时间字段是否过期。
3. 如果过期，则启动新的线程进行数据同步，当前线程正常返回数据，但这个数据可能不是最新的。

两种方案各有利弊。如果选择数据的强一致性，建议使用互斥锁的方案，性能上可能不高，因为锁需要等待，也有可能产生死锁的问题。

如果优先考虑高可用性，性能比较高，建议选择给key添加逻辑过期时间，但是数据同步做不到强一致性。

## 4. 缓存雪崩及应对措施
**缓存雪崩：** 在同一时间段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。

**解决方案：**  
1. 给不同的key设置随机过期时间
2. 利用redis集群提高服务的可用性（哨兵和集群模式）
3. 给缓存业务添加降级限流策略（降级可作为系统的保底策略，适用于穿透、击穿和雪崩）
4. 给业务添加多级缓存 （Guava和Caffeine）

